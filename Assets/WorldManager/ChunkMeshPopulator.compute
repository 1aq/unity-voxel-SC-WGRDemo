// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Vertex
{
    float3 position;
    float3 normal;
    uint id;
};

StructuredBuffer<unsigned int> chunkData;
RWStructuredBuffer<unsigned int> indirectBuffer;
RWStructuredBuffer<Vertex> vertexBuffer;

[numthreads(8, 8, 8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int currPos = id.x * 32 * 32 + id.y * 32 + id.z;
    if (chunkData[currPos] > 0)
    {
        // Count vertices number
        int vCount = 0;
        bool3 facePos = bool3(false, false, false);
        bool3 faceNeg = bool3(false, false, false);

        if (id.x <= 0 || chunkData[currPos - 32 * 32] == 0)
        {
            faceNeg.x = true;
            vCount += 6;
        }
        if (id.y <= 0 || chunkData[currPos - 32] == 0)
        {
            faceNeg.y = true;
            vCount += 6;
        }
        if (id.z <= 0 || chunkData[currPos - 1] == 0)
        {
            faceNeg.z = true;
            vCount += 6;
        }
        if (id.x >= 31 || chunkData[currPos + 32 * 32] == 0)
        {
            facePos.x = true;
            vCount += 6;
        }
        if (id.y >= 31 || chunkData[currPos + 32] == 0)
        {
            facePos.y = true;
            vCount += 6;
        }
        if (id.z >= 31 || chunkData[currPos + 1] == 0)
        {
            facePos.z = true;
            vCount += 6;
        }

        int i;
        InterlockedAdd(indirectBuffer[0], vCount, i);

        float4 blockSize = float4(1.0, 1.0, 1.0, 0);
        float3 blockOffset = float3(-0.05, -0.05, -0.05) + float3(id.x, id.y, id.z);

        Vertex v;

        v.id = chunkData[currPos];

        // Left
        if (faceNeg.x)
        {
            v.normal = float3(-1, 0, 0);

            v.position = blockOffset;
            vertexBuffer[i] = v;

            v.position = blockOffset + blockSize.wwz;
            vertexBuffer[i + 1] = v;

            v.position = blockOffset + blockSize.wyw;
            vertexBuffer[i + 2] = v;

            v.position = blockOffset + blockSize.wyw;
            vertexBuffer[i + 3] = v;

            v.position = blockOffset + blockSize.wwz;
            vertexBuffer[i + 4] = v;

            v.position = blockOffset + blockSize.wyz;
            vertexBuffer[i + 5] = v;

            i += 6;
        }

        // Bottom
        if (faceNeg.y)
        {
            v.normal = float3(-1, 0, 0);

            v.position = blockOffset;
            vertexBuffer[i] = v;

            v.position = blockOffset + blockSize.xww;
            vertexBuffer[i + 1] = v;

            v.position = blockOffset + blockSize.wwz;
            vertexBuffer[i + 2] = v;

            v.position = blockOffset + blockSize.wwz;
            vertexBuffer[i + 3] = v;

            v.position = blockOffset + blockSize.xww;
            vertexBuffer[i + 4] = v;

            v.position = blockOffset + blockSize.xwz;
            vertexBuffer[i + 5] = v;

            i += 6;
        }

        // Back
        if (faceNeg.z)
        {
            v.normal = float3(0, 0, -1);

            v.position = blockOffset;
            vertexBuffer[i] = v;

            v.position = blockOffset + blockSize.wyw;
            vertexBuffer[i + 1] = v;

            v.position = blockOffset + blockSize.xww;
            vertexBuffer[i + 2] = v;

            v.position = blockOffset + blockSize.xww;
            vertexBuffer[i + 3] = v;

            v.position = blockOffset + blockSize.wyw;
            vertexBuffer[i + 4] = v;

            v.position = blockOffset + blockSize.xyw;
            vertexBuffer[i + 5] = v;

            i += 6;
        }

        // Right
        if (facePos.x)
        {
            v.normal = float3(1, 0, 0);

            v.position = blockOffset + blockSize.xww;
            vertexBuffer[i] = v;

            v.position = blockOffset + blockSize.xyw;
            vertexBuffer[i + 1] = v;

            v.position = blockOffset + blockSize.xwz;
            vertexBuffer[i + 2] = v;

            v.position = blockOffset + blockSize.xwz;
            vertexBuffer[i + 3] = v;

            v.position = blockOffset + blockSize.xyw;
            vertexBuffer[i + 4] = v;

            v.position = blockOffset + blockSize.xyz;
            vertexBuffer[i + 5] = v;

            i += 6;
        }

        // Top
        if (facePos.y)
        {
            v.normal = float3(0, 1, 0);
            
            v.position = blockOffset + blockSize.wyw;
            vertexBuffer[i] = v;
            
            v.position = blockOffset + blockSize.wyz;
            vertexBuffer[i + 1] = v;
            
            v.position = blockOffset + blockSize.xyw;
            vertexBuffer[i + 2] = v;
            
            v.position = blockOffset + blockSize.xyw;
            vertexBuffer[i + 3] = v;
            
            v.position = blockOffset + blockSize.wyz;
            vertexBuffer[i + 4] = v;
            
            v.position = blockOffset + blockSize.xyz;
            vertexBuffer[i + 5] = v;

            i += 6;
        }

        // Forward
        if (facePos.z)
        {
            v.normal = float3(0, 0, 1);

            v.position = blockOffset + blockSize.wwz;
            vertexBuffer[i] = v;

            v.position = blockOffset + blockSize.xwz;
            vertexBuffer[i + 1] = v;

            v.position = blockOffset + blockSize.wyz;
            vertexBuffer[i + 2] = v;

            v.position = blockOffset + blockSize.wyz;
            vertexBuffer[i + 3] = v;

            v.position = blockOffset + blockSize.xwz;
            vertexBuffer[i + 4] = v;

            v.position = blockOffset + blockSize.xyz;
            vertexBuffer[i + 5] = v;

            i += 6;
        }
    }
}
